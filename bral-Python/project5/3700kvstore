#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)


#####################################
############## Globals ###############
#####################################
term = 0
logIndex = 0
log = {}
store = {}
votedFor = -1
replica_ids.append(my_id)


def initial_election():
	ranks = {x: int(x, 16) for x in replica_ids}
	min_id = min(ranks.values())
	global term
	term += 1 #increment term on every election

	for replica in ranks:
		if ranks[replica] == min_id:
			return replica





#####################################
############## Leader ###############
#####################################
LEADER_ID = initial_election()
IS_LEADER = LEADER_ID == my_id
okays = {}




def send_redirect(msg):
	redirect_msg = {"src": msg['dst'], "dst": msg["src"], "leader": LEADER_ID, "type": "redirect", "MID": msg['MID']}
	sock.send(json.dumps(redirect_msg))


def answer_get(msg):
	#get it from the 'official' log
	if msg['key'] in log:
		return_msg = {"src": msg['dst'],
					  "dst": msg['src'],
					  "leader": msg['leader'],
					  "type": "ok",
					  "MID": msg['MID'],
					  "value": log[msg['key']]}
	else:
		return_msg = {"src": msg['dst'],
					  "dst": msg['src'],
					  "leader": msg['leader'],
					  "type": "fail",
					  "MID": msg['MID'],
					  "value": ""}

	sock.send(json.dumps(return_msg))


def answer_put(msg):
	global store

	# Store data in store dict regardless of src address for reference
	store[msg["key"]] = msg['value']


	# if leader, broadcast to followers
	if IS_LEADER:
		for rep in replica_ids:
			to_followers = {"src": LEADER_ID, 'dst': rep, "leader": LEADER_ID, "type": "put", "MID": msg['MID'],
							'key': msg['key'], 'value': msg['value']}
			sock.send(json.dumps(to_followers))

		#only commit to official log when majority of replicas have responded
		if len(wait_for_responses()) >= len(replica_ids) // 2 + 1:
			to_client = {"src": LEADER_ID, 'dst': msg["src"], "leader": LEADER_ID, "type": "ok", "MID": msg['MID']}
			commit_msg(msg)
			sock.send(json.dumps(to_client))

	elif msg["src"] == LEADER_ID:
		# If a put is received from the leader, send an ACK back to the leader
		to_leader = {"src": msg['dst'], 'dst': LEADER_ID, "leader": LEADER_ID, "type": "ok", "MID": msg['MID']}
		sock.send(json.dumps(to_leader))


def commit_msg(msg):
	global logIndex, log
	log[msg["key"]] = msg['value']
	logIndex += 1


def wait_for_responses():
	timer_start = time.time()
	responses = {}

	while time.time() - timer_start < .01:
		ready = select.select([sock], [], [], 0.1)[0]
		for s in ready:
			msg_raw = s.recv(32768)
			if len(msg_raw) == 0:
				continue

			msg = json.loads(msg_raw)

			#what if im the leader and a new replica comes online?
			if msg["src"] not in replica_ids:
				continue

			responses[msg["src"]] = msg
	return responses


#####################################################
#                   Main Function                   #
#####################################################

while True:
	ready = select.select([sock], [], [], 0.1)[0]

	if sock in ready:
		msg_raw = sock.recv(32768)
		if len(msg_raw) == 0:
			continue

		msg = json.loads(msg_raw)

		# handle get() and put() from clients
		if msg["dst"] == LEADER_ID or (msg["src"] == LEADER_ID and msg["dst"] in replica_ids):

			if msg['type'] == 'get':
				answer_get(msg)

			elif msg["type"] == 'put':
				answer_put(msg)

		# only redirect if I am not the leader but the message I got thinks I am
		elif not IS_LEADER & msg['leader'] == my_id:
			send_redirect(msg)

	else:

		continue
