#!/usr/bin/python -u
#
# Project 3 Starter Code
#

# PLAN: BUILD OUT TCP RENO THEN GET RID OF SLOW START
# Because minimum and maximum bandwidth, latency, etc will be passed on the command line, we will have that information.
# Essentially, we can use it to start at a higher initial value for cwnd that allows us to be more efficient


import sys
import socket
import time
import datetime
import select
import json
import unittest
import random

# Size of each message
MSG_SIZE = 1500

# Total size of the data portion of the packet only
DATA_SIZE = 1000



# Roundtrip timeout setting
TIMEOUT = 2

RTT = None

# Current sequence number to be incremented
SEQUENCE = 0

# Contains msgs that have been read from STDIN
# as a dict where key is seq # of packet
TO_SEND = {}

# Contains msgs that are currently in flight
ACKS_RECIEVED = []

# Determine if newline has been detected in loaded packets
EOF_DETECTED = False

# Used for slow start/congestion control to determine how many packets to load
# at once
CURR_WINDOW = 1

# Current number of packets that are on the way
INFLIGHT = 0

# Counts duplicate ACKs for fast retransmit
DUP_ACKS = 0

# TODO DELETE
INFLIGHT_MSGS = {}

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":") + 1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


def send_next_packet(p):
    global SEQUENCE
    global EOF_DETECTED
    global INFLIGHT
    global CURR_WINDOW
    global INFLIGHT_MSGS

    #log("Current Window: {}".format(CURR_WINDOW))
    #log("Current # of msgs Inflight: {}".format(INFLIGHT))

    # Although TCP needs to wait for all packets to ACK back before sending more packets, we should
    # allow for continuous sending and then reorder everything at the end
    # Keys of SENDING_QUEUE are seq # so we sort to make sure packets are sent in order
    # for packet in p:
    #     log("This is the packet in send: " + str(packet))
        #log("Index: {}, Packet: {}".format(index, packet))

        # Sets INFLIGHT counter to the length of the dict of msgs currently in transit
        # If that number is greater than the current window, we return True instead of breaking to
        # Signal to the main method that there are more packets to come in the next round

        # INFLIGHT = len(INFLIGHT_MSGS)
        # if INFLIGHT > CURR_WINDOW:
        #     log("Window hit")
        #     return True
    try:
        # sock.sendto returns length of msg sent
        # checks that msg was fully sent
        if sock.sendto(TO_SEND[p], dest) < len(TO_SEND[p]):
            log("[error] unable to fully send packet")
        # If successfully sent, add the current packet to the INFLIGHT_MSGS dict
        # Then pop from the SENDING_QUEUE dict
        else:
            INFLIGHT_MSGS[p] = TO_SEND[p]
            log("[send data] " + str(p) + " (" + str(len(TO_SEND[p])) + ")")
    except KeyError:
        log("Continuing on KeyError in send")
        return
    # If an EOF packet is detected, return null to signal to the main method that there are no more packets to send
    if EOF_DETECTED:
        log("EOF Return from sending")
        return


def setup_handshake():
    pass


def read_user_input():
    global SEQUENCE
    global TO_SEND
    global EOF_DETECTED
    global CURR_WINDOW
    global DATA_SIZE

    # LOAD ALL PACKETS AT ONCE INTO SENDING_QUEUE
    while not EOF_DETECTED:
        # Get data for the packet
        data = sys.stdin.read(DATA_SIZE)

        # If there is data to be added, check that it is of size DATA_SIZE (global variable)
        # If not, it must be the last packet, so set EOF_DETECTED to True
        if len(data) > 0:
            if len(data) < DATA_SIZE:
                log("File size less than global DATA_SIZE")
                EOF_DETECTED = True

            # Add to the SENDING_QUEUE dict at the current SEQUENCE number, then increment SEQUENCE safely
            msg = json.dumps({"sequence": SEQUENCE, "data": data, "ack": False, "eof": EOF_DETECTED})
            TO_SEND[SEQUENCE] = msg
            SEQUENCE += 1

        # If data is of length 0, replace the most recent entry to SENDING_QUEUE with a copy where the only change
        # Is that "eof" is set to True instead of False. Then break out of look
        else:
            temp = json.loads(TO_SEND[SEQUENCE - 1])
            temp["eof"] = True
            TO_SEND[SEQUENCE - 1] = json.dumps(temp)
            log("Breaking out of read")
            break


# int -> void
# safely wraps seq # if it exceeds 32-bit value
def increment_seq(msg_size):
    global SEQUENCE
    # Uses absolute value to deal with wraparound
    if SEQUENCE + msg_size > 2**32 - 1:
        SEQUENCE = abs((2**32 - 1) - (SEQUENCE + msg_size))
    else:
        SEQUENCE += msg_size

    return SEQUENCE


def connection_teardown():
    pass


# float, float, float -> float
def estimate_roundtrip(old_rtt, new_sample, alpha=0.4):

    # Needed for first estimation where there is no old
    if old_rtt is None:
        old_rtt = new_sample

    updated = alpha * old_rtt + (1 - alpha) * new_sample
    log("NEW RTT IS " + str(updated))
    return updated


def check():
    diff = set(TO_SEND.keys()).difference(set(ACKS_RECIEVED))
    log("JAMESON ACKS RECIEVED: " + str(set(ACKS_RECIEVED)) + "   TO_SEND: " + str(TO_SEND.keys()))
    if len(diff) == 0:
        return True
    else:
        return diff



def mainHelper(result):

    if result:
        log("In result block")
        (data, addr) = result
        log("data is " + str(data))
        decoded = json.loads(data)
        for entry in decoded['ack']:
            try:
                log("ENTRY IN DECODED IS " + str(entry))
                if entry == 'kill':
                    log("Exiting after kill")
                    sys.exit(0)

                ACKS_RECIEVED.append(entry)
                log(str(ACKS_RECIEVED))
                # If ACK is valid (in the keyset of INFLIGHT_MSGS dict),
                # reset timeout clock, pop the relevant packet from INFLIGHT_MSGS, reset the length of
                # INFLIGHT_MSGS, increment CURR_WINDOW by 1, and send next packet

                # This may be needed later
                # if decoded['ack'] in INFLIGHT_MSGS:
                # 	start = time.time()
                # 	INFLIGHT_MSGS.pop(decoded['ack'])
                # 	INFLIGHT = len(INFLIGHT_MSGS)
                # 	CURR_WINDOW += 1
                # 	log("[recv ack] " + str(decoded['ack']))

                # Try to send next packet; break if no more data

                # Might not be right
                # if not check() == True:
                #     log("broke")
                #     break
                # else:
                #     log("Back to top of loop")
                #     continue

            except (ValueError, KeyError, TypeError) as e:
                log(str(e))
                log("[recv corrupt packet]")


def main(packets):
    # Read in all user input and set timeout clock
    global RTT
    result = None

    if len(packets) == 0:
    # Now send packets
        for i in range(0,len(TO_SEND)):
            log("TOP OF SEND LOOP")
            start = time.time()
            send_next_packet(i)
            #RTT = estimate_roundtrip(RTT, end - start)
            #sock.settimeout(RTT)

    else:
        log("finish me should be here!!!!!!!!!!!!!!!!")
        # iterate through packets given thru args packets
        for packet in packets:
            log("TOP OF !!ReSEND!! LOOP")
            start = time.time()
            send_next_packet(packet)
            # maybe add a timer
            #result = sock.recvfrom(MSG_SIZE)
            # mainHelper(result)

    log("ABOUT TO LISTEN FOR RESULT")
    try:
        result = sock.recvfrom(MSG_SIZE)
        end = time.time()
        RTT = estimate_roundtrip(RTT, end - start)
        log("FINISHED LISTENING FOR RESULT")
    except socket.timeout:
        log("SENDING timeout while waiting on result")
        pass

    sock.settimeout(estimate_roundtrip(RTT, time.time() - start))
    mainHelper(result)


############  CONTROL ##############
start = time.time()
read_user_input()
idx = []
while True:
    main(idx)
    if check() == True:
        log("Exited with no more packets to send")
        sock.sendto(json.dumps({"eof": True, "data": "", "sequence": SEQUENCE, "ack": False}), dest)
        sys.exit(0)
    else:
        # either boolean (sent everything) or a list
        idx = sorted(check())