#!/usr/bin/env python

import argparse, socket, time, json, select, struct, math, copy, logging

DEBUG = True
logging.basicConfig(filename='router.log', level=logging.DEBUG)
#DEBUG = False
#logging.basicConfig(filename='example.log', level=logging.CRITICAL)



parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


##########################################################################################

class Router:
	routes = None
	updates = None
	relations = None
	sockets = None
	fwd_table = None

	def __init__(self, networks):
		self.routes = {}
		self.updates = {}  # Save update annoucements as { src : annoucement_msg }
		self.relations = {}  # {"192.168.0.2" : "peer"}
		self.sockets = {}  # socket.socket() for "192.168.0.2"
		self.fwd_table = []  #

		for relationship in networks:
			# Ex: 192.168.0.2-peer
			network, relation = relationship.split("-")  # network = "192.168.0.2", relation = "peer"
			# if DEBUG:
			print("Starting socket for {} - {}".format(network, relation))
			self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
			self.sockets[network].setblocking(0)
			self.sockets[network].connect(network)

			self.relations[network] = relation

		print("\n\n\n\n")
		return

	def lookup_routes(self, daddr):
		""" Lookup all valid routes for an address """
		# !!! DADDR IS A FULL PACKET, NOT JUST ADDRESS !!!
		# Perform DFS for the router at IP address == daddr
		# Return list of lists representing possible paths
		outroutes = []
		curr_max_match = 0
		# Simple count of valid paths by checking forwarding table.
		# For each entry in fwd_table, checks equality of subnets of fwd_table entry and dst
		#for entry in self.fwd_table:
		#	if self.get_subnet(daddr["dst"], entry["netmask"]) == self.get_subnet(entry["network"], entry["netmask"]):
		#		outroutes.append(entry)
		
		for entry in self.fwd_table:
			num_matches = 0
			split_dst = daddr["dst"].split(".")
			split_entry = entry["network"].split(".")
			
			for index, octet in enumerate(split_dst):
				if octet == split_entry[index]:
					num_matches += 1
				else:
					break
			print("Compared {} and {}, found {} octet matches".format(daddr["dst"], entry["network"], num_matches))
			
			if num_matches > curr_max_match:
				curr_max_match = num_matches
				outroutes = [entry]
			elif num_matches == curr_max_match:
				outroutes.append(entry)


		return outroutes

	def get_shortest_as_path(self, routes):
		""" select the route with the shortest AS Path """
		# TODO
		outroutes = []

		curr_shortest_as = None
		for route in routes:
			if curr_shortest_as is None:
				curr_shortest_as = len(route["ASPath"])
			print("Current Shortest AS set to {}".format(len(route["ASPath"])))
			if len(route["ASPath"]) <= curr_shortest_as:
				outroutes.append(route)
			print("{} routes with shortest_path".format(len(outroutes)))
		print(outroutes)
		return outroutes

	def get_highest_preference(self, routes):
		""" select the route with the highest localpref """
		# TODO
		if len(routes) == 0:
			return

		outroutes = []
		curr_max_lp = None

		for route in routes:
			if curr_max_lp is None:
				curr_max_lp = route["localpref"]

			if route["localpref"] >= curr_max_lp:
				curr_max_lp = route["localpref"]
				outroutes.append(route)

		return outroutes

	def get_self_origin(self, routes):
		""" select self originating routes """
		outroutes = []

		if len(routes) <= 1:
			return routes

		if "True" not in [d["selfOrigin"].decode('utf-8') for d in routes]:
			return routes
		else:
			for route in routes:
				if route['selfOrigin'].decode('utf-8') == "True":
					print("Route added: {}".format(route))
					outroutes.append(route)

		return outroutes

	def get_origin_routes(self, routes):
		""" select origin routes: EGP > IGP > UNK """
		# TODO
		outroutes = []

		if len(routes) <= 1:
			return routes

		origin_ranks = {"IGP": 1,
						"EGP": 2,
						"UNK": 3}

		# curr_best_origin = origin_ranks[routes[0]["origin"]]
		curr_best_origin = None
		for route in routes:
			if curr_best_origin is None:
				curr_best_origin = origin_ranks[route["origin"]]

			if origin_ranks[route["origin"]] <= curr_best_origin:
				curr_best_origin = origin_ranks[route["origin"]]
				outroutes.append(route)

		return outroutes

	def filter_relationships(self, srcif, routes):
		""" Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
		outroutes = []
		if self.relations[srcif] == CUST:
			print("{} SRCIF IS CUST\n".format(srcif))
			return routes
		elif self.relations[srcif] == PEER:
			print("{} SRCIF IS PEER\n".format(srcif))
			for route in routes:
				if self.relations[route["peer"]] == CUST:
					outroutes.append(route)
			
		else:
			print("SRCIF IS PROV")
			for route in routes:
				if self.relations[route["peer"]] != PEER:
					outroutes.append(route)
		
		return outroutes[0] if len(outroutes) == 1 else None

	def get_min_ip(self, routes):
		temp = {}

		for route in routes:
			temp[int("".join(route["peer"].split(".")))] = route

		return temp[min(list(temp.keys()))]["peer"]

	def send_no_route(self, srcif, packet):
		self.forward(srcif, {"src": srcif[:-1] + "1",
					  "dst": packet["src"],
					  "type": "no route",
					  "msg": {}})

	def get_route(self, srcif, daddr):
		"""	Select the best route for a given address	"""
		# TODO
		peer = None
		routes = self.lookup_routes(daddr)
		print(routes)
		if len(routes) == 0 or routes is None:
			packet_copy = copy.deepcopy(daddr)
			logging.warning("No Routes Found\n")

			# Forwards message back to sender
			print("Sending packet back {}\n".format(packet_copy))
			self.send_no_route(srcif, packet_copy)

			return

		elif len(routes) == 1:
			packet_copy = copy.deepcopy(daddr)
			print("1 route found, forwarding packet to {}".format(packet_copy["dst"]))
			# Forwards message using only available path
			if self.filter_relationships(srcif, routes) is not None:
				return self.forward(routes[0]["peer"], packet_copy)
			else:
				return self.send_no_route(srcif, packet_copy)

		# Rules go here
		else:
			print("{} routes found, finding best route\n".format(len(routes)))
			# 1. Highest Preference
			routes = self.get_highest_preference(routes)
			print("Route list after get_highest_preference: {}\n".format(routes))
			# 2. Self Origin
			routes = self.get_self_origin(routes)
			print("Route list after get_self_origin: {}\n".format(routes))
			# 3. Shortest ASPath
			routes = self.get_shortest_as_path(routes)
			print("Route list after get_shortest_as_path: {}\n".format(routes))
			# 4. EGP > IGP > UNK
			routes = self.get_origin_routes(routes)
			print("Route list after get_origin_routes: {}\n".format(routes))
			# 5. Lowest IP Address
			# TODO assign peer to return of filter_relationships 
			# Once it is writter
			#peer = self.get_min_ip(routes)
			routes = self.get_min_ip(routes)
			# Final check: enforce peering relationships
			peer = self.filter_relationships(srcif, routes)

		return self.forward(peer, daddr) if peer is not None  else self.send_no_route(srcif, daddr)
		

	def forward(self, srcif, packet):
		"""	Forward a data packet	"""
		logging.warning("Forwarding {} to {}".format(packet["type"], packet["dst"]))

		self.sockets[srcif].sendto(json.dumps(packet), packet["dst"])
		for each in self.fwd_table:
			print(each)
		print("\n")

		return

	def coalesce(self):
		"""	coalesce any routes that are right next to each other	"""
		# TODO (this is the most difficult task, save until last)
		#netmask has to be the same
		#go to end of prefix mask
		#only aggregate routes going to same output port
		print("Looking for routes to aggregate")

		old = self.fwd_table
		to_keep = []
		to_remove = []
		for index, entry_a in enumerate(self.fwd_table):
			if entry_a in to_remove:
				continue

			for entry_b in self.fwd_table[index:]:
				if entry_a == entry_b or entry_b in to_remove:
					continue			
	
				elif entry_a["netmask"] == entry_b["netmask"] and self.get_subnet(entry_a["network"], entry_a["netmask"]) == self.get_subnet(entry_b["network"], entry_b["netmask"]) and entry_a["peer"] == entry_b["peer"]:
						print("Aggregating {} and {}".format(entry_a["network"], entry_b["network"]))
						entry_a["network"] = self.get_subnet(entry_a["network"], self.decrement_netmask(entry_a["netmask"]))
						print("Product is {}".format(entry_a["network"]))	
						to_keep.append(entry_a)
						to_remove.append(entry_b)			
					
				else:
					to_keep.append(entry_a)
					to_keep.append(entry_b)

		updated = []
		for each in to_keep:
			if each not in to_remove and each not in updated:
				updated.append(each)
		if updated != old:
			self.fwd_table = updated

	def decrement_netmask(self, netmask):
		split_nm = netmask.split(".")
		
		# Get index of final non-zero octet in netmask
		# If all octets are non-zero, return final position 
		# as target. Else, make target the index before the first 0
		if "0" not in split_nm:	
			target = 3
		else:
			target = split_nm.index("0") - 1

		if split_nm[target] == "255":
			split_nm[target] = "254"

		else:
			split_nm[target][split_nm[target].index("0") - 1] = 0
		
		print("{} converted to {}".format(netmask, ".".join(split_nm)))
		return ".".join(split_nm)

	def update(self, srcif, packet):
		"""	handle update packets	"""

		# Save update message for later
		self.updates[packet["src"]] = packet

		# Add an entry to the forwarding table
		# TODO: Add functionality to prevent duplicate entries	
		self.fwd_table.append({"network": packet["msg"]["network"],
							   "netmask": packet["msg"]["netmask"],
							   "localpref": packet["msg"]["localpref"],
							   "selfOrigin": packet["msg"]["selfOrigin"],
							   "ASPath": packet["msg"]["ASPath"],
							   "origin": packet["msg"]["origin"],
							   "peer": packet["src"]})
		if len(self.fwd_table) > 1:
			self.coalesce()
		print("Got update from {}".format(srcif))


		# Update all neighbors if srcif is CUST
		# Update received from a customer: send updates to all other neighbors
		if self.relations[srcif] == CUST:
			for sock in self.sockets:
				# Prevent self-sending
				if sock != packet["src"]:
					packet_copy = copy.deepcopy(packet)

					# Update is received at the router and passed to other sockets
					# so old dst becomes new src and sock becomes new dst
					packet_copy["src"], packet_copy["dst"] = packet_copy["dst"], sock

					self.forward(sock, packet_copy)
		else:
			for sock in self.sockets:

				# Prevent self-sending
				if sock != packet["src"] and self.relations[sock] == CUST:
					packet_copy = copy.deepcopy(packet)

					# Update is received at the router and passed to other sockets
					# so old dst becomes new src and sock becomes new dst
					packet_copy["src"], packet_copy["dst"] = packet_copy["dst"], sock

					self.forward(sock, packet_copy)
		return

	def revoke(self, srcif, packet):
		"""	handle revoke packets	"""
		rev_msg = packet["msg"]  # packet message contents

		temp = []
		for unreachable in rev_msg:
			for entry in self.fwd_table:
				if entry["network"] == unreachable["network"] and entry["netmask"] == unreachable["netmask"] and entry["peer"] == packet["src"]:
					print("{} revoked".format(unreachable["network"]))
					continue
				else:
					if entry not in temp:
						temp.append(entry)
			self.fwd_table = temp
		
		
		if self.relations[srcif] == CUST:	
			for sock in self.sockets:
				if sock != packet["src"]:
					packet_copy = copy.deepcopy(packet)

					# Update is received at the router and passed to other sockets
					# so old dst becomes new src and sock becomes new dst
					packet_copy["src"], packet_copy["dst"] = packet_copy["dst"], sock

					self.forward(sock, packet_copy)
		else:
			for sock in self.sockets:
				if sock != packet["src"] and self.relations[sock] == CUST:
					packet_copy = copy.deepcopy(packet)	
					packet_copy["src"], packet_copy["dst"] = packet_copy["dst"], sock

					self.forward(sock, packet_copy)
			

			# TODO
		return True

	def dump(self, packet):
		"""	handles dump table requests	"""
		print(packet)

		# Forward the current forwarding table for comparison.
		# Filters socket list to exclude socket that sent the packet then takes first of list
		# self.forward([s for s in self.sockets if s != packet["src"]][0],
		self.forward(packet["src"],
					 {"src": packet["dst"],
					  "dst": packet["src"],
					  "type": "table",
					  "msg": self.fwd_table})

	def handle_packet(self, srcif, packet):
		if packet["type"] == UPDT:
			logging.warning("Handling update")
			self.update(srcif, packet)
		if packet["type"] == DATA:
			logging.warning("Checking for possible routes data message")
			self.get_route(srcif, packet)
		if packet["type"] == DUMP:
			logging.warning("Dumping forwarding table")
			self.dump(packet)
		if packet["type"] == RVKE:
			print("Revoking entry in forwarding table")
			self.revoke(srcif, packet)
		if packet["type"] == NRTE:
			logging.warning("No route for packet")
			self.send_no_route(srcif, packet)
		if packet["type"] == "wait":
			logging.warning("wait")
			pass

		return False

	def send_error(self, conn, msg):
		pass


	# returns subnet of IP based on netmask
	def get_subnet(self, ip, netmask):
		split_ip = ip.split(".")
		split_nm = netmask.split(".")
		temp = []

		# For each chunk of IP, bitwise-AND with netmask and append to temp
		for index, each in enumerate(split_ip):
			temp.append(str(int(each) & int(split_nm[index])))

		return ".".join(temp)

	def run(self):
		while True:
			socks = select.select(self.sockets.values(), [], [], 0.1)[0]
			for conn in socks:
				try:
					k = conn.recv(65535)
				except:
					# either died on a connection reset, or was SIGTERM's by parent
					return
				if k:
					for sock in self.sockets:
						if self.sockets[sock] == conn:
							srcif = sock
							msg = json.loads(k)
					if not self.handle_packet(srcif, msg):
						self.send_error(conn, msg)
				else:
					return

		return


if __name__ == "__main__":
	router = Router(args.networks)
	router.run()
