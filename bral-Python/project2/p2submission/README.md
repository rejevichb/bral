Our high-level approach to this milestone was to first map out the networks in the test cases visually. Understanding the connection schemes and underlying structure of the network made it much easier to plan our path forward. We then looked at the run() method to determine what sequence of steps needed to be carried out: 1) determine what actually needed to be done with the packet, 2) flesh out the details of each relevant packet type, 3) listing edge cases that would throw errors within our program for each packet type.

The most time-consuming part of the project was understanding how one socket actually reached another, and how to successfully manipulate the packets to provide the correct information. Especially with nested dictionary structures, wrapping our heads around certain tasks was difficult at times.

As for testing, we didn't write any actual unit tests for the code as we had no idea what to provide as an interface for the simulator. Instead, we used print statements at various points in the processing pipeline to know 1) if the right data was being passed along and if not 2) at which point in the code was the bug coming up. This was particularly useful for the level 2 tests because we needed to implement the route priority system. Using the print statements, we could see at which point in the 5 priority checks someething was going wrong.
